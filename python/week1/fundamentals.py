# -*- coding: utf-8 -*-
"""Python Fundamentals - 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f9qaI570ZDJH971tIr9l04iagUjpJ8lJ

## Tuples
"""

# Define a new tuple
tuple_1 = ("Max", 28, "New York")

print(tuple_1)
print(type(tuple_1))

"""# Python Fundamentals - Week 2"""

# Parentheses are optional
tuple_2 = "Linda", 25, "Miami"
print(tuple_2)
print(type(tuple_2))

# Tuples are immutable (ERROR)
tuple_1[2] = "Boston"

# Lists are mutable (unlike tuples)
list_1 = ["Max", 28, "New York"]

list_1[2] = "Boston"

print(list_1)

# Tuples are iterable (combine tuples and lists)
new_tuple = (["Alice", 25, "New York"], ["Max", 28, "Boston"])

# Use list comprehensions to split and bundle corresponding elements
names = [item[0] for item in new_tuple]
ages = [item[1] for item in new_tuple]
cities = [item[-1] for item in new_tuple]

print(names)
print(ages)
print(cities)

myTuple = (1,2)
myTuple = myTuple + (3,)
# newTuple = myTuple + (3,)
print(myTuple, type(myTuple))

# Tuple unpacking
person = ("Alice", 25, "New York")

name, age, city = person

print(name)
print(age)
print(city)

# Integers: One element Tuple definition

tuple_1 = (5) # Not a tuple

print(tuple_1)
print(type(tuple_1))
print()

tuple_2 = (5,) # tuple

print(tuple_2)
print(type(tuple_2))
print()

# Also true for strings
new_tuple = ('a',)

print(new_tuple)
print(type(new_tuple))

"""#### Iteration through Tuples"""

# Iterate through a tuple
tuple_1 = ("Max", 28, "New York")

# Iterate by item
for item in tuple_1:
    print(item, end="  ")

n = len(tuple_1)

# Iterate by index
for i in range(n):
    print(i, tuple_1[i])

# Iterate by index and item (enumerate)
for idx, val in enumerate(tuple_1):
    print(idx, val)

# Search a tuple
tuple_1 = ("Max", 28, "New York")

result1 = "New York" in tuple_1
result2 = "Chicago" in tuple_1
result3 = "Boston" not in tuple_1

print(result1, result2, result3)

# Some tuples properties
my_tuple = ('a','p','p','l','e')

# len() : get the number of elements in a tuple
print(len(my_tuple))

# count(x) : Return the number of items that is equal to x
print(my_tuple.count('p'))

# index(x) : Return index of first item that is equal to x
print(my_tuple.index('l'))

# repetition (such as lists and strings)
print(('a','p','p','l','e') * 2)

"""#### Type Conversions"""

# Convert itearable to tuple
my_list = [1, 2, 3]
tuple_4 = tuple(my_list)
print(tuple_4)

# Convert list to tuple
my_list = ['a', 'b', 'c', 'd']
list_to_tuple = tuple(my_list)
print(list_to_tuple)

# Convert tuple to list
my_tuple = ('a', 'b', 'c', 'd')
tuple_to_list = list(my_tuple)
print(tuple_to_list)

# convert string to tuple
my_str = 'Hello'
str_to_tuple = tuple(my_str)
print(str_to_tuple)

"""#### Memory Usage"""

my_list = [0, 1, 2, 5, 10]
my_tuple = (0, 1, 2, 5, 10)

# compare the size
import sys

print(sys.getsizeof(my_list), "bytes")
print(sys.getsizeof(my_tuple), "bytes")

"""#### Function Output"""

# Using a tuple to return multiple values
def divide(a, b):
    quotient = a // b
    remainder = a % b
    return quotient, remainder

# result = divide(10, 3) # 10 = 3 x 3 + 1

quotient, remainder = divide(10, 3)
print(quotient, remainder)

# result = divide(10, 3)
# print(result[0], result[1])

"""## Sets"""

# Define a new set
set1 = {1, 5, 10, 4, 6, 9, 19}

print("Our set:", set1)
print("\nlength of the set:", len(set1))
print("\nMaximum element of the set", max(set1))

empty_list = [] # list()
empty_tuple = () # tuple()
empty_set = set()
empty_dictionary = {} # dict()

# Define an empty set
empty_set = set()
print(empty_set)
print(type(empty_set))

# Don't confuse it with dictionary
empty_dict = {}
# empty_dict = dict()
print(empty_dict)
print(type(empty_dict))

# Set is not indexed
set1 = {1, 5, 10, 4, 6, 9, 19}

set1[2]

# Sets are heterogeneous
new_set = {2, 1, "a"}
print(new_set)

# Sets remove duplicate elements
numbers = {2, 4, 6, 6, 2, 8, 6, 6, 6, 6}
print(numbers)

"""#### Sets Built-in Functions"""

# Set built-in functions
fruits = {"apple", "banana", "cherry"}
print(fruits)

# Adding an element
fruits.add("orange")
print(fruits)

# Removing an element
fruits.remove("cherry")
print(fruits)

more_fruits = {"orange", "strawberry", "kiwi"}
print(more_fruits)

# Union
all_fruits = fruits.union(more_fruits)
print(fruits)
print(more_fruits)
print(all_fruits)

# Intersection
common_fruits = fruits.intersection(more_fruits)
print(common_fruits)

# Difference
different_fruits = all_fruits.difference(common_fruits)
print(different_fruits)

# Update
fruits = {"apple", "banana", "orange"}
more_fruits = {"orange", "strawberry", "kiwi"}
fruits.update(more_fruits)
print(fruits)

# Removed element has to be in the set (ERROR)
fruits.remove("watermelon")

# discard(x): removes x, nothing if element is not present
fruits.discard("banana")
print(fruits)

fruits.discard("blueberry")
print(fruits)

# clear() : remove all elements
fruits.clear()
print(fruits)

"""## Class Activity

### LeetCode 217

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
"""

# Solution 1
def containsDuplicate(nums):
    checker = set()
    for num in nums:
        if num not in checker:
            checker.add(num)
        else:
            return True
    return False

# Solution 2
def containsDuplicate(nums):
    return len(nums) != len(set(nums))

# Test Case 1
nums = [1, 2, 3, 1]
print(containsDuplicate(nums))

# Test Case 2
nums = [1, 2, 3, 4]
print(containsDuplicate(nums))

# Test Case 3
nums = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
print(containsDuplicate(nums))

"""### LeetCode 349

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
"""

# Solution 1
def intersection(nums1, nums2):
    # convert both to sets then intersection
    set1 = set(nums1)
    set2 = set(nums2)
    return list(set1.intersection(set2))

# Solution 2
def intersection(nums1, nums2):
    return list(set(nums1).intersection(set(nums2)))

# Test Case 1
nums1 = [1, 2, 2, 1] # {1, 2}
nums2 = [2, 2] # {2}
print(intersection(nums1, nums2))

# Test Case 2
nums1 = [4, 9, 5] # {4, 9, 5}
nums2 = [9, 4, 9, 8, 4] # {9, 4, 8}
print(intersection(nums1, nums2))

"""## Dictionaries"""

# Define a new dictionary
capital_city = {"Nepal": "Kathmandu", "Italy": "Rome", "England": "London"}
print(capital_city)
print(type(capital_city))

# Retrieve value for a given key
print("Capital of Italy:", capital_city["Italy"])

capital_city["Spain"]

# Retrieve value with a default option
print(capital_city.get("Spain", "Country not provided"))

# Store a new key-value pair
capital_city["Japan"] = "Tokyo"
print("Updated Dictionary: ", capital_city)

"""#### Dictionary Methods"""

# Another example
person = {
    "name": "Alice",
    "age": 25,
    "city": "New York"
}
print(person)

# Get dict keys
keys = person.keys()
print(keys)
print(type(keys))

# Get dict vals
values = person.values()
print(values)
print(type(values))

# Get dict key-val pairs
items = person.items()
print(items)
print(type(items))

# Converted to list
print(list(keys))
print(list(values))
print(list(items))

# Removing values

# pop - returns the value
val = person.pop('age')

print("Returned value:", val)
print("Updated dictionary:", person)

val = person.popitem()

print("Returned value:", val)
print("Updated dictionary:", person)

# Del - does not return the value
del person['name']
print(person)

"""#### Iteration and Existence"""

# Membership Test for Dictionary Keys
squares = {
    1: 1,
    3: 9,
    5: 25,
    7: 49,
    9: 81
}
print(squares)

# Iterate through a dict
print("Iteration through dict:")

for key in squares:
    print(key, squares[key])

# Iterate through keys
print("Iteration through dict keys:")

for key in squares.keys():
    print(key, squares[key])

# # Iterate through vals
print("Iteration through dict vals:")

for value in squares.values():
    print(value)

# Iterate through key-val pairs
print("Iteration through dict key-val pairs:")

for item in squares.items():
    print(item)

"""#### Exercise"""

print("The original dictionary:", squares)

# Check existence - True = 1 / False = 0
a = 1 in squares # True
b = 2 not in squares # True
c = 49 in squares # False
d = 49 in squares.keys() # False
e = 49 in squares.values() # True

result = (a+b+c)**d+e

print(result)

"""#### Exercise"""

my_dict = {3: 9, 6: 36, 9: 81}
print(my_dict)

print(my_dict[3])

print(my_dict[2])

print(my_dict.get(2, "!"))

"""#### Exercise"""

new_dict = {}
print(new_dict)

# Tuple as key - immutable
new_dict[(8, 3, 4)] = 15
print(new_dict)

# List as key - mutable
new_dict[[3, 4]] = 7
print(new_dict)

"""## Modules

#### Built-in Modules
"""

import math

num = 16
print(math.sqrt(num))

num = 4
print(math.factorial(num))

print(math.pi)

val = math.pi
print(math.sin(val))

# Ceiling of a number
num = 2.3
print(math.ceil(num))
print(math.floor(num))

import random

random.randint(1, 10)

round(random.random(), 2)

random.choice([3, 4, 6, 10])

"""#### from ... import ..."""

from math import sqrt, floor, ceil

# square root of a number
num = 16
print(sqrt(num))

from random import randint

# Draw random integer in a range
print(randint(1, 10))

"""#### User-Defined Modules"""

import math_calculator as mc

mc.pi = 3.14

mc.e = 2.73

mc.e

print(mc.pi, mc.person1['name'])

print(mc.find_sqaure(10))

from math_calculator import find_square_root

print(find_square_root(49))

def find_square_root(a, b):
    return a**0.5, b**0.5

find_square_root(36, 49)

"""## Functional Programming

#### Lambda Function
"""

# Normal functions
def add_1(a, b):
    return a + b

added_val_1 = add_1(5, 10)
print(added_val_1)

# Lambda function
add_2 = lambda a, b: a + b

added_val_2 = add_2(5, 10)
print(added_val_2)

# Another example
def greet1():
    print("Hello World")

greet2 = lambda : print("Hello World")

greet3 = lambda name: print("Hello " + name)

greet1()
greet2()
greet3("New World")

"""#### map()

The map() function in Python does not modify the original iterable in-place. Instead, it applies a specified function to each element of the iterable and returns an iterable containing the results. The original iterable remains unchanged.
"""

# Example - with normal Python function
numbers = [2, 4, 8, 6, 8, 10]

def square(number):
    return number ** 2

numbersSquare_list = list(map(square, numbers))

print(numbersSquare_list)

# with Lambda function
numbersSquare_list = list(map(lambda x: x**2, numbers))
print(numbersSquare_list)

"""#### filter()"""

scores = [66, 90, 68, 59, 76, 60, 88, 74, 81, 65]

def is_A_student(score):
    return score > 75

filtered_scores = filter(is_A_student, scores)

over_75 = list(filtered_scores)
print("Filtered list:", over_75)

filtered_scores = filter(lambda x: x > 75, scores)

over_75 = list(filtered_scores)
print("Filtered list:", over_75)

"""## Class Activity"""

# What is the output?

# lambda function with trenary operator
func = lambda a, b: b - a if a <= b else a * b

print(func(10, 2), func(2, 10))

# Write a code to keep negative numbers (use both ordinary and lambda functions)

numbers = [1, 0, -3, 6, 5, -9, 24]

less_than_zero = list(filter(lambda x: x<0, numbers))

print(less_than_zero)

# Write a code to find the length of each string

strings = ["apple", "fig", "orange"]

lengths_list = list(map(lambda s: len(s), strings))
# lengths_list = list(map(len, strings))

print(lengths_list)

# Write a code to keep even numbers

numbers = [1, 2, 3, 4, 5, 6, 7, 8]

even_numbers_list = list(filter(lambda a: a % 2 == 0, numbers))

print(even_numbers_list)

# Write a code to keep vowels

letters = ['a', 'b', 'd', 'e', 'i', 'j', 'o']
vowels = ['a', 'e', 'i', 'o', 'u']

filtered_vowels = list(filter(lambda x: x in vowels, letters))

print(filtered_vowels)

"""### LeetCode 169"""

def some_func():
    print(2)

def majorityElement(nums):

    freq = dict()

    for num in nums:
        if freq.get(num, None) is None:
            freq[num] = 1
        else:
            freq[num] += 1

    for key in freq:
        if freq[key] > (len(nums) // 2):
            return key

# Test Case 1
nums = [3, 2, 3]
print(majorityElement(nums))

# Test Case 2
nums = [2, 2, 1, 1, 1, 2, 2]
print(majorityElement(nums))

"""## Scope of Variables"""

def my_function():
    x = 5 # local variable
    print(x)

x = 4 # global variable
print(x)
my_function()
print(x)

def my_function():
    z = 5 # local variable
    print(z + y)

y = 4 # global variable
my_function()
print(y)
# print(z) # Error: Not defined!

# This function modifies global variable 's'
def f():
    global s
    print(s)
    s = "CD" # global variable
    print(s)

s = "AB" # global variable
print(s)
f()
print(s)

# Example
s1 = "Maria" # global variable

def f():
    s3 = "Nicole" # local variable
    print(s1)
    print(s2)
    print(s3)

s2 = "Peter" # global variable
f()

"""### Call by Value"""

# Integer
def modify_value(x):
    x += 1
    return x

original_variable = 10

print("Original value:", original_variable)

result = modify_value(original_variable)

print("\nOriginal value after modification:", original_variable)

print("\nModified value:", result)

# Strings
def modify_string(input_string):
    input_string += " World!"
    return input_string

original_string = "Hello"

print("Original string:", original_string)

modified_string = modify_string(original_string)

print("\nOriginal string after update:", original_string)

print("\nModified string:", modified_string)

"""### Call by Reference"""

# Lists
def modify_list(lst):
    lst.append(4)

original_list = [1, 2, 3]

print("Original list:", original_list)

modify_list(original_list)

print("Modified list:", original_list)

# Dictionaries
def modify_dict(input_dict):
    input_dict['key2'] = 'new_value'

original_dict = {'key1': 'value1', 'key2': 'value2'}

print("Original Dictionary:", original_dict)

modify_dict(original_dict)

print("Modified Dictionary:", original_dict)

"""## Class Activity

### Global vs Local

#### What is the output of this code?
"""

# What is the output?

a = 1 # global variable

def f():
    print(a, end="")

def g():
    a = 2 # local to g()
    print(a, end="")

def h():
    global a
    a = 3 # local to h()
    print(a, end="")

print(a, end="")
f()
print(a, end="")
g()
print(a, end="")
h()
print(a)

"""#### What is the output of this code?"""

x = 10 # global var

def outer_function():

    y = 20 # local to outer / global to inner

    def inner_function():
        global x
        nonlocal y

        x = 30 # overwrites globally
        y = 40 # overwrites locally

        print(x, end=" ")
        print(y, end=" ")

    inner_function()
    print(x, end=" ")
    print(y, end=" ")

outer_function()
print(x)

"""### Call by Value or Reference

#### What is the output of this code?
"""

def modifier(a, b, c, d):
    a.append(3)
    b += 4
    c['a'] = 3
    d += "World"

var1 = [-1]   # mutable
var2 = 0      # immutable
var3 = {}     # mutable
var4 = "Hey " # immutable

modifier(var1, var2, var3, var4)

# [-1, 3] 0 {'a':3} "Hey "

print(var1, var2, var3, var4)

"""### LeetCode 1"""

def twoSum(nums, target):
    dict1 = {}
    for i in range(len(nums)):
        dict1[nums[i]] = i
    for i in range(len(nums)):
        complement = target - nums[i]
        if complement in dict1 and dict1[complement] != i:
            return [i, dict1[complement]]

def twoSum(nums, target):
    dict1 = {}
    for i in range(len(nums)):
        complement = target - nums[i]
        if complement in dict1:
            return [i, dict1[complement]]
        dict1[nums[i]] = i

# Test Case 1
nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))

# Test Case 2
nums = [3, 2, 4]
target = 6
print(twoSum(nums, target))

# Test Case 3
nums = [3, 3]
target = 6
print(twoSum(nums, target))